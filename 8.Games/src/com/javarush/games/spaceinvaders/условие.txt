Игра Space Invaders (1/34)
Сегодня мы предлагаем тебе написать увлекательную игру — Space Invaders. Как всегда, начнем с правил.
Цель игры: игроку нужно уничтожить все корабли инопланетян.
Игрок управляет лазерной пушкой, передвигая её горизонтально, в нижней части экрана.
У игрока есть бесконечное количество "патронов". Попадая в инопланетный корабль, игрок убивает его и получает за это очки.
На старте игры корабли инопланетян находятся в верхней части экрана. Они движутся по горизонтали и, достигая края игрового поля, опускаются на ряд ниже, постепенно приближаясь к игроку.
По мере того, как кораблей инопланетян становится меньше, их скорость движения увеличивается.
После разгрома всех врагов игроку засчитывается победа.
Инопланетяне пытаются уничтожить пушку, стреляя по ней. Если инопланетяне попадают в пушку, игрок терпит поражение.
Если хотя бы один из противников достигает нижней части экрана, происходит инопланетный захват, и игра также заканчивается.
Выше рядов с кораблями противника находится "босс". Если игрок уничтожит его, он получит бонусные очки.
Итак, начнем. Для начала нам понадобится класс игры SpaceInvadersGame, который наследует класс Game. Он содержит методы, которые помогут нам в реализации игры.
Теперь зададим игровое поле. Для запуска игры нам необходимо переопределить метод initialize(), в котором, в свою очередь, нужно вызвать метод setScreenSize(int, int).
Этот метод задает ширину и высоту игрового поля, которые он принимает в качестве параметров. Их будем хранить в переменных.
Чтобы успешно справиться с задачей Space Invaders, рекомендуем прочесть статью про раздел "Игры". В ней ты найдешь информацию, которая будет полезна при написании игр.

Требования:
1. Должен существовать публичный класс SpaceInvadersGame.
2. Класс SpaceInvadersGame должен быть наследником класса Game.
3. В классе SpaceInvadersGame должно существовать публичное статическое final int поле WIDTH, проинициализированное при объявлении значением 64.
4. В классе SpaceInvadersGame должно существовать публичное статическое final int поле HEIGHT, проинициализированное при объявлении значением 64.
5. В классе SpaceInvadersGame должен быть переопределен метод initialize() родительского класса Game.
6. В методе initialize() должен быть вызван метод setScreenSize(int, int) класса Game c параметрами WIDTH и HEIGHT.
7. В классе SpaceInvadersGame должен быть импорт всего содержимого пакета com.javarush.engine.cell.


==================================================================================================================================


Игра Space Invaders (2/34)
Все игровые действия происходят в космосе. Для его отрисовки объявим метод drawField().
Создавать все элементы игры будем в методе createGame(), а отрисовывать их — в методе drawScene().
Все объекты создаются при запуске игры, поэтому в методе initialize() вызовем setScreenSize(int, int), а после него — метод createGame().

Требования:
1. В классе SpaceInvadersGame должен существовать приватный метод void createGame().
2. В классе SpaceInvadersGame должен существовать приватный метод void drawScene().
3. В классе SpaceInvadersGame должен существовать приватный метод void drawField().
4. В методе drawScene() должен быть вызван метод drawField().
5. В методе createGame() должен быть вызван метод drawScene().
6. В методе initialize() должен быть вызван метод createGame().
7. В методе initialize() метод createGame() должен вызываться после setScreenSize(int, int).


==================================================================================================================================


Игра Space Invaders (3/34)
Давай реализуем метод drawField() — закрасим игровое поле одним цветом. Для этого нужно каждой ячейке установить цвет и пустую строку. В этом нам поможет метод setCellValueEx(int, int, Color, String) класса Game, где первые два параметра — координаты x и y ячейки, третий — цвет фона, а последний - значение ячейки, которое должно отображаться на игровом поле. Список доступных цветов ты найдешь в enum com.javarush.engine.cell.Color "игрового движка". Значение ячейки устанавливать не нужно, поэтому передадим пустую строку.
Например, чтобы раскрасить ячейку с координатами x = 0 и y = 2 в черный цвет, нужно вызвать метод:
setCellValueEx(0, 2, Color.BLACK, ""). Чтобы закрасить не одну ячейку, а все — нам нужно взять каждую строку игрового поля, пройтись по каждой ячейке строки и установить ей цвет и значение. В этом нам помогут циклы.
Пример:
for (int y = 0; y < высота игрового поля; y++) {
    for (int x = 0; x < ширина игрового поля; x++) {
        setCellValueEx(x, y, цвет ячейки, пустая строка);
    }
}
Поскольку в игре будут задействованы разные игровые объекты, их общие характеристики, такие как координаты положения на игровом поле, будут описаны в родительском классе GameObject. Для классов всех игровых объектов создадим отдельный пакет gameobjects. Первыми игровыми объектами будут звезды. Для их описания создадим класс Star в пакете gameobjects и унаследуем его от класса GameObject.

Требования:
1. В методе drawField() необходимо вызвать для всех ячеек отображения метод setCellValueEx(int, int, Color, String) с параметрами: координаты x и y, любой цвет (например, Color.BLACK) и пустую строку.
2. В пакете gameobjects в отдельном файле должен существовать публичный класс GameObject.
3. В классе GameObject должно существовать публичное поле x типа double.
4. В классе GameObject должно существовать публичное поле y типа double.
5. В классе GameObject должен существовать публичный конструктор с двумя параметрами типа double, который устанавливает соответствующие значения полям x и y.
6. В пакете gameobjects в отдельном файле должен существовать публичный класс Star.
7. Класс Star должен быть наследником класса GameObject.
8. В классе Star должен существовать публичный конструктор с двумя параметрами типа double, который вызывает конструктор базового класса с этими же параметрами.


==================================================================================================================================


Игра Space Invaders (4/34)
Для отображения звезды можно использовать любой символ из стандарта Юникод. Его будем хранить в поле STAR_SIGN класса Star.
Чтобы отображать звезду на игровом поле, создадим метод draw(Game). В нем будем вызывать метод setCellValueEx у объекта типа Game, который получаем в качестве параметра. В метод setCellValueEx передадим координаты звезды, цвет фона, символ звезды, цвет и размер этого символа. Обрати внимание, что у звезды тип координат x и y — double, поэтому при вызове метода setCellValueEx их нужно привести к типу int. Чтобы добавить звезды в игру, создадим для них список и метод, который будет заполнять этот список новыми звездами. А для отображения звезд на игровом поле, нужно вызвать метод отрисовки draw(Game) у каждой звезды после отрисовки игрового поля.

Требования:
1. В классе Star должно существовать приватное статическое final поле String STAR_SIGN, инициализированное при объявлении. Например, можно использовать UTF-8 символ звезды "\u2605".
2. В классе Star должен существовать публичный метод void draw(Game).
3. В методе draw(Game) у объекта типа Game должен быть вызван метод setCellValueEx(int, int, Color, String, Color, int) с параметрами: x, y, Color.NONE, STAR_SIGN, <цвет звезды>, 100. (<цвет звезды> используй какой тебе нравиться, например, Color.WHITE).
4. В классе SpaceInvadersGame должно существовать приватное поле stars типа List<Star>.
5. В классе SpaceInvadersGame должен существовать приватный метод void createStars().
6. Поле stars должно быть проинициализировано в методе createStars() новым объектом типа ArrayList<Star>.
7. В методе createStars() необходимо добавить 8 новых объектов типа Star в список stars. Координаты в пределах игрового поля для каждой звезды выбери сам.
8. В методе createGame() метод createStars() должен вызываться до drawScene().
9. В методе drawField() после отрисовки поля у каждого объекта из списка stars необходимо вызвать метод draw(Game). В качестве параметра передай в метод "this".
10. В классе Star должен быть импорт всего содержимого пакета com.javarush.engine.cell.


==================================================================================================================================


Игра Space Invaders (5/34)
Кроме звезд в игре буду задействованы другие игровые объекты, а именно — космические корабли. Внешний вид игрового объекта на плоскости задается в виде матрицы matrix, поэтому добавим поле matrix в классе GameObject. Кроме формы объекта, матрица содержит порядковый номер цвета из списка цветов com.javarush.engine.cell.Color. Габаритные размеры объекта вынесем в отдельные поля — ширину и высоту. Чтобы отобразить игровой объект на экране, создадим и реализуем метод draw(Game game). В этом методе для каждой ячейки матрицы matrix будем вызывать метод setCellValueEx(int x, int y, Color color, String text) у объекта типа Game, который получаем в качестве параметра. Для отрисовки элементов матрицы matrix на игровом поле необходимо учитывать, что координаты x и y объекта класса GameObject — это координаты левой верхней ячейки матрицы matrix на игровом поле.
Пример:
Тут картинка (21.png)!
Как видно из примера, левая верхняя ячейка матрицы игрового объекта имеет координаты на игровом поле x = 2 и y = 4, но относительно своей матрицы - это координаты x = 0 и y = 0. Исходя из этого, в метод setCellValueEx будут передаваться координаты верхней левой ячейки матрицы игрового объекта на игровом поле + координаты ячейки в матрице игрового объекта (x = 2 + 0, y = 4 + 0).
Пример:
game.setCellValueEx(x объекта на игровом поле + x в матрице, y объекта на игровом поле + y в матрице, цвет, пустая строка);
Обрати внимание, что color — это цвет элемента из матрицы объекта, который можно получить так: Color.values()[matrix[i][j]], где i – координата y в матрице matrix, j – координата x в матрице matrix.

Требования:
1. В классе GameObject должно существовать публичное поле matrix типа int[][].
2. В классе GameObject должно существовать публичное поле width типа int.
3. В классе GameObject должно существовать публичное поле height типа int.
4. В классе GameObject должен существовать публичный метод void setMatrix(int[][]).
5. Метод setMatrix(int[][]) должен устанавливать поле matrix, равное полученному параметру метода.
6. В методе setMatrix(int[][]) поле width должно инициализироваться значением matrix[0].length.
7. В методе setMatrix(int[][]) поле height должно инициализироваться значением matrix.length.
8. В классе GameObject должен существовать публичный метод void draw(Game).
9. В методе draw(Game) для каждой ячейки матрицы matrix должен быть вызван метод setCellValueEx(int, int, Color, String) у объекта типа Game. В качестве параметров необходимо передать: x объекта на игровом поле + x в матрице, y объекта на игровом поле + y в матрице, цвет и пустую строку.
10. В классе GameObject должен быть импорт всего содержимого пакета com.javarush.engine.cell.


==================================================================================================================================


Игра Space Invaders (6/34)
Сейчас мы создадим класс Ship, который будет хранить в себе общие свойства космических кораблей. В нем будет метод setStaticView, который на данный момент устанавливает матрицу, а позже будет еще и задавать анимацию.
Первым сделаем корабль представителя вражеского флота EnemyShip. Его матрицу мы прислали тебе в классе ShapeMatrix.

Требования:
1. В пакете gameobjects в отдельном файле должен существовать публичный класс Ship.
2. Класс Ship должен быть наследником класса GameObject.
3. В классе Ship должен существовать публичный конструктор с двумя параметрами типа double, который вызывает конструктор базового класса с этими же параметрами.
4. В классе Ship должен существовать публичный метод void setStaticView(int[][] viewFrame).
5. В методе setStaticView(int[][] viewFrame) необходимо вызвать метод setMatrix(int[][]) базового класса. В качестве параметра передай в метод viewFrame.
6. В пакете gameobjects в отдельном файле должен существовать публичный класс EnemyShip.
7. Класс EnemyShip должен быть наследником класса Ship.
8. В классе EnemyShip должен существовать публичный конструктор с двумя параметрами типа double, который вызывает конструктор базового класса с этими же параметрами.
9. В конструкторе класса EnemyShip необходимо вызвать метод setStaticView(int[][]). В качестве параметра передай ShapeMatrix.ENEMY.


==================================================================================================================================


Игра Space Invaders (7/34)
В этой части мы подготовим основу для вражеского флота. Для этого создадим класс EnemyFleet. Он будет хранить список кораблей, количество рядов кораблей(ROWS_COUNT), количество кораблей в ряду(COLUMNS_COUNT) и расстояние между левыми верхними углами соседних кораблей(STEP). Создавать корабли и заполнять ими список(ships) мы будем в методе createShips, но к его реализации приступим позже.

Требования:
1. В пакете gameobjects в отдельном файле должен существовать публичный класс EnemyFleet.
2. В классе EnemyFleet должно существовать приватное статическое final поле int ROWS_COUNT, инициализированное при объявлении значением 3.
3. В классе EnemyFleet должно существовать приватное статическое final поле int COLUMNS_COUNT, инициализированное при объявлении значением 10.
4. В классе EnemyFleet должно существовать приватное статическое final поле int STEP, инициализированное при объявлении значением ShapeMatrix.ENEMY.length + 1.
5. В классе EnemyFleet должно существовать приватное поле ships типа List<EnemyShip>.
6. В классе EnemyFleet должен существовать приватный метод void createShips().
7. Поле ships должно быть инициализировано в методе createShips() новым объектом типа ArrayList<EnemyShip>.


==================================================================================================================================


Игра Space Invaders (8/34)
Продолжим работу над созданием вражеского флота. Для этого в методе createShips заполним список ships.
Учтем, что оптимальным расстоянием от верхней границы экрана до первого сверху ряда кораблей будет 12 ячеек.
Для добавления вражеского флота в игру создадим поле enemyFleet в классе SpaceInvadersGame и проинициализируем его новым объектом типа EnemyFleet. Вражеские корабли создаются при вызове метода createShips в конструкторе объекта EnemyFleet
Так как игра динамическая, нам нужно периодически перерисовывать экран и выполнять другие действия. Все, что будет происходить на каждом шаге, выполняется в методе onTurn(int).
Чтобы задать частоту работы этого метода, мы будем использовать метод setTurnTimer. Он принимает на вход параметр — длительность каждого шага в миллисекундах. Т.е. при значении шага в 40 мс (0,04с) мы получим частоту работы метода onTurn, равную 25 разам в секунду (1/0,04с). Если все сделал правильно, запустив программу, ты увидишь вражеский флот.

Требования:
1. В методе createShips() класса EnemyFleet необходимо создать и добавить в список ships ROWS_COUNT * COLUMNS_COUNT новых вражеских кораблей.
2. Каждый вражеский корабль необходимо создавать с параметрами конструктора: x * STEP, y * STEP + 12, где x — переменная цикла от 0 включительно до COLUMNS_COUNT не включительно; y — переменная цикла от 0 включительно до ROWS_COUNT не включительно.
3. В классе EnemyFleet должен существовать один публичный конструктор без параметров.
4. В конструкторе класса EnemyFleet необходимо вызвать метод createShips().
5. В классе EnemyFleet должен существовать публичный метод void draw(Game game).
6. В методе draw(Game game) у каждого вражеского корабля из списка ships необходимо вызвать метод draw(Game). В качестве параметра передай game.
7. В классе SpaceInvadersGame должно существовать приватное поле enemyFleet типа EnemyFleet.
8. Поле enemyFleet должно быть проинициализировано в методе createGame() новым объектом типа EnemyFleet до вызова метода drawScene().
9. В методе drawScene() после вызова метода drawField() у объекта enemyFleet должен быть вызван метод draw(Game). В качестве параметра передай в метод "this".
10. В классе SpaceInvadersGame должен быть переопределен метод onTurn(int) родительского класса Game.
11. В методе onTurn(int) должен быть вызван метод drawScene().
12. В методе createGame() класса SpaceInvadersGame должен быть вызван метод setTurnTimer(int) класса Game с параметром 40.
13. В классе EnemyFleet должен быть импорт класса com.javarush.engine.cell.Game.


==================================================================================================================================


Игра Space Invaders (9/34)
В игре будет все двигаться, а значит, нам нужно определять направление движения объектов. Хранить направления удобно в enum'е.
Движение вражеского корабля опишем в методе move. В зависимости от направления и скорости, он меняет соответствующую координату. У движения вниз скорость постоянная — 2.
Поскольку вражеский флот движется от одного края игрового поля к другому, нам нужно контролировать достижение флотом боковых границ.

Требования:
1. В отдельном файле должен существовать публичный enum Direction со значениями: RIGHT, LEFT, UP, DOWN.
2. В классе EnemyShip должен существовать публичный метод void move(Direction direction, double speed).
3. В методе move(Direction direction, double speed) необходимо увеличить значение поля x на speed, если direction равно Direction.RIGHT.
4. В методе move(Direction direction, double speed) необходимо уменьшить значение поля x на speed, если direction равно Direction.LEFT.
5. В методе move(Direction direction, double speed) необходимо увеличить значение поля y на 2, если direction равно Direction.DOWN.
6. В классе EnemyFleet должен существовать приватный метод double getLeftBorder().
7. Метод getLeftBorder() должен возвращать минимальную координату x среди всех вражеских кораблей из списка ships.
8. В классе EnemyFleet должен существовать приватный метод double getRightBorder().
9. Метод getRightBorder() должен возвращать максимальное из значений (x + width) среди всех вражеских кораблей из списка ships.


==================================================================================================================================


Игра Space Invaders (10/34)
Согласно концепции игры, чем меньше кораблей, тем выше скорость их движения по горизонтали.
Реализуем эту зависимость в методе getSpeed. Обрати внимание, что максимальная скорость вражеских кораблей не должна превышать значение 2. Также добавим в класс EnemyFleet направление движения и метод move.
В классе SpaceInvadersGame нам понадобится метод moveSpaceObjects, в котором будем двигать объекты.
Корабли передвигаются на каждом такте игры, поэтому метод moveSpaceObjects нужно вызывать в методе onTurn.
Чтобы сразу увидеть результат движения на экране, нужно вызвать метод moveSpaceObjects до перерисовки экрана.

Требования:
1. В классе EnemyFleet должно существовать приватное поле Direction direction, инициализированное при объявлении значением Direction.RIGHT.
2. В классе EnemyFleet должен существовать приватный метод double getSpeed().
3. Метод getSpeed() должен возвращать минимум среди значений: 2.0 и (3.0 / количество кораблей в списке ships).
4. В классе EnemyFleet должен существовать публичный метод void move().
5. В классе SpaceInvadersGame должен существовать приватный метод void moveSpaceObjects().
6. В методе moveSpaceObjects() у объекта enemyFleet необходимо вызвать метод move().
7. В методе onTurn(int) класса SpaceInvadersGame необходимо вызвать метод moveSpaceObjects() до вызова drawScene().


==================================================================================================================================


Игра Space Invaders (11/34)
Когда корабли подлетают к краю экрана, они меняют направление на противоположное и опускаются ниже.
Для этого нам нужно реализовать метод move класса EnemyFleet.

Требования:
1. Метод move() класса EnemyFleet ничего не делает, если в списке ships нет кораблей.
2. Если значение поля direction равно Direction.LEFT и результат вызова метода getLeftBorder() отрицательный, полю direction необходимо установить значение Direction.RIGHT.
3. Если значение поля direction равно Direction.RIGHT и результат вызова метода getRightBorder() больше, чем (SpaceInvadersGame.WIDTH), полю direction необходимо установить значение Direction.LEFT.
4. В методе move() необходимо вызвать метод getSpeed().
5. Если значение поля direction было изменено, у каждого объекта из списка ships необходимо вызвать метод move(Direction, double) с параметрами: Direction.DOWN, результат вызова метода getSpeed().
6. Если значение поля direction не было изменено, у каждого объекта из списка ships необходимо вызвать метод move(Direction, double) с параметрами: direction, результат вызова метода getSpeed().


==================================================================================================================================


Игра Space Invaders (12/34)
Создадим класс Bullet, отвечающий за пули. Конструктор этого класса будет принимать координаты x, y и направление полета.
Также в конструкторе будет вызываться метод setMatrix с параметром матрицы пули(ShapeMatrix.BULLET), которую ты найдешь в классе ShapeMatrix. Так как пули летают только вверх или вниз, при их движении меняется только координата y.
Введем переменную dy, которая будет отвечать за величину изменения координаты y. При движении вверх dy имеет отрицательное значение, а при движении вниз — положительное. Поэтому в методе move, будет достаточно увеличить координату y на dy.
Объявим переменную isAlive, которая будет показывать, "жива" пуля или нет.
При создании она "жива", а при столкновении с кораблем противника, она "умирает".
Это поведение мы реализуем позже.

Требования:
1. В пакете gameobjects в отдельном файле должен существовать публичный класс Bullet.
2. Класс Bullet должен быть наследником класса GameObject.
3. В классе Bullet должно существовать приватное поле dy типа int.
4. В классе Bullet должен существовать публичный конструктор с тремя параметрами (double x, double y, Direction direction), который вызывает конструктор базового класса с параметрами x и y.
5. В классе Bullet должно существовать публичное поле isAlive типа boolean, инициализированное при объявлении значением true.
6. В конструкторе класса Bullet необходимо вызвать метод setMatrix(int[][]) базового класса. В качестве параметра передай в метод ShapeMatrix.BULLET.
7. В конструкторе класса Bullet необходимо инициализировать поле dy значением -1, если параметр конструктора direction равен Direction.UP.
8. В конструкторе класса Bullet необходимо инициализировать поле dy значением 1, если параметр конструктора direction не равен Direction.UP.
9. В классе Bullet должен существовать публичный метод void move().
10. В методе move() значение поля y необходимо увеличить на значение поля dy.


==================================================================================================================================


Игра Space Invaders (13/34)
Введем переменную COMPLEXITY, которая отвечает за сложность игры, а именно — за вероятность выстрела вражеского корабля за один шаг игры.
Все корабли должны стрелять, поэтому в класс Ship добавим метод fire.
Так как экземпляр этого класса мы не будем создавать, сделаем этот метод "заглушкой", а реализовывать его будем в классах-наследниках.
Чтобы пуля вылетала из носовой пушки, нужно передать в конструктор правильные координаты.

Требования:
1. В классе SpaceInvadersGame должно существовать публичное статическое final int поле COMPLEXITY, проинициализированное при объявлении значением 5.
2. В классе Ship должен существовать публичный метод Bullet fire().
3. Метод fire() класса Ship должен возвращать null.
4. В классе EnemyShip должен быть переопределен метод Bullet fire().
5. Метод fire() класса EnemyShip должен возвращать новый объект типа Bullet. В качестве параметров конструктора передай x + 1, y + height, Direction.DOWN.


==================================================================================================================================


Игра Space Invaders (14/34)
Создадим и реализуем метод fire у EnemyFleet. Этот метод будет вызывать метод fire у одного из кораблей флота, выбранного случайно.
Кроме того, флот будет стрелять с вероятностью COMPLEXITY процентов.

Требования:
1. В классе EnemyFleet должен существовать публичный метод Bullet fire(Game).
2. Метод fire(Game) класса EnemyFleet должен возвращать null, если в списке ships нет вражеских кораблей.
3. Метод fire(Game) класса EnemyFleet должен вызывать метод getRandomNumber(int) у объекта типа Game с параметром (100 / SpaceInvadersGame.COMPLEXITY).
4. В методе fire(Game) класса EnemyFleet необходимо вернуть null, если результат вызова метода getRandomNumber(int) у объекта типа Game с параметром (100 / SpaceInvadersGame.COMPLEXITY) больше нуля.
5. Метод fire(Game) класса EnemyFleet должен вызывать метод getRandomNumber(int) у объекта типа Game с параметром, равным количеству вражеских кораблей в списке ships.
6. Метод fire(Game) класса EnemyFleet должен вызывать у корабля из списка ships c индексом, равным результату вызова game.getRandomNumber(ships.size()), метод fire().
7. Метод fire(Game) класса EnemyFleet должен возвращать результат вызова метода fire() у вражеского корабля.


==================================================================================================================================


Игра Space Invaders (15/34)
Все вражеские пули будем хранить в переменной enemyBullets класса SpaceInvadersGame. Добавим их отрисовку и движение в соответствующие методы.
Чтобы удалить потраченные пули, создадим и реализуем метод removeDeadBullets() в классе SpaceInvadersGame.
Для удаления можно либо использовать итератор, либо создать копию списка enemyBullets и проходить по ней циклом.
Если в результате проверки объект нужно удалить из списка, вызываем enemyBullets.remove(bullet).
К потраченным пулям относятся те, которые вылетели за пределы экрана, и те, которые попали в цель (isAlive == false).
Добавим вспомогательный метод check(). На данном этапе он будет вызывать метод removeDeadBullets(). Впоследствии в нем будут происходить различные проверки на каждом шаге игры.
С такой же частотой мы будем вызывать метод fire() у флота, при котором один из вражеских кораблей может выстрелить.
Если выстрел произошел, метод вернет пулю, которую нужно добавить в список.

Требования:
1. В классе SpaceInvadersGame должно существовать приватное поле enemyBullets типа List<Bullet>.
2. Поле enemyBullets должно быть проинициализировано в методе createGame() новым объектом типа ArrayList<Bullet> до вызова метода drawScene().
3. В методе drawScene() после вызова метода drawField() у каждого объекта из списка enemyBullets должен быть вызван метод draw(Game). В качестве параметра передай в метод "this".
4. В методе moveSpaceObjects() у каждого объекта из списка enemyBullets должен быть вызван метод метод move().
5. В классе SpaceInvadersGame должен существовать приватный метод void removeDeadBullets().
6. В методе removeDeadBullets() необходимо из списка enemyBullets удалить все "неживые" пули и те, которые вылетели за пределы экрана (координата y пули больше либо равна HEIGHT - 1).
7. В классе SpaceInvadersGame должен существовать приватный метод void check().
8. В методе check() необходимо вызвать метод removeDeadBullets().
9. В методе onTurn(int) класса SpaceInvadersGame необходимо вызвать метод check() до вызова метода drawScene().
10. В методе onTurn(int) необходимо один раз вызвать у объекта enemyFleet метод fire(Game) с параметром "this" до вызова метода drawScene().
11. Если результат вызова метода fire(Game) у объекта enemyFleet вернул не null, необходимо в список enemyBullets добавить этот результат. Добавление выполняется до вызова метода drawScene().


==================================================================================================================================


Игра Space Invaders (16/34)
Теперь создадим корабль игрока. Для этого нам нужен класс PlayerShip. В его конструкторе будем устанавливать значения координат таким образом, чтобы корабль отображался внизу экрана по центру.
Кроме этого, конструктор задает внешний вид корабля, устанавливая матрицу PLAYER, которую мы тебе прислали в классе ShapeMatrix.
У корабля может быть два состояния: "живой" или "неживой". Чтобы описать эти состояния, добавим поле isAlive в общий класс кораблей Ship.
Когда пуля попадает в корабль, они (пуля и корабль) уничтожаются, поэтому добавим метод kill. При его вызове будем "убивать" корабль и пулю.

Требования:
1. В пакете gameobjects в отдельном файле должен существовать публичный класс PlayerShip.
2. Класс PlayerShip должен быть наследником класса Ship.
3. В классе PlayerShip должен существовать публичный конструктор без параметров, который вызывает конструктор базового класса с параметрами: SpaceInvadersGame.WIDTH / 2.0, SpaceInvadersGame.HEIGHT - ShapeMatrix.PLAYER.length - 1
4. В конструкторе класса PlayerShip необходимо вызвать метод setStaticView(int[][]). В качестве параметра передай ShapeMatrix.PLAYER.
5. В классе Ship должно существовать публичное поле boolean isAlive, инициализированное при объявлении значением true.
6. В классе Ship должен существовать публичный метод void kill().
7. В методе kill() класса Ship необходимо установить полю isAlive значение false.
8. В классе Bullet должен существовать публичный метод void kill().
9. В методе kill() класса Bullet необходимо установить значение false полю isAlive.


==================================================================================================================================


Игра Space Invaders (17/34)
Добавим в класс PlayerShip метод, который проверяет, попали ли вражеские пули в корабль игрока (метод isCollision класса GameObject).
Если было попадание, он "убивает" корабль и пулю. Также добавим корабль игрока в класс игры, отрисуем его и внесем проверку попаданий в соответствующий метод.

Требования:
1. В классе PlayerShip должен существовать публичный метод void verifyHit(List<Bullet> bullets).
2. Метод verifyHit(List<Bullet> bullets) не должен ничего делать, если в списке bullets отсутствуют пули (список пустой).
3. В методе verifyHit(List<Bullet> bullets), если игрок жив, необходимо проверить пересечение игрока с каждой из живых пуль из списка bullets (используй метод isCollision(GameObject)).
4. Если результат проверки вернул true, необходимо вызвать метод kill().
5. Если результат проверки вернул true, необходимо вызвать метод kill() у пули, с которой произошло пересечение.
6. В классе SpaceInvadersGame должно существовать приватное поле playerShip типа PlayerShip.
7. Поле playerShip должно быть проинициализировано в методе createGame() новым объектом типа PlayerShip до вызова метода drawScene().
8. В методе drawScene() после вызова метода drawField() у объекта playerShip должен быть вызван метод draw(Game). В качестве параметра передай в метод "this".
9. В методе check() класса SpaceInvadersGame у объекта playerShip необходимо вызвать метод verifyHit(List<Bullet>) с параметром enemyBullets, до вызова метода removeDeadBullets().


==================================================================================================================================


Игра Space Invaders (18/34)
На данном этапе мы подготовим анимацию для крушения кораблей. Для этого нам понадобится поле frames типа List<int[][]>, которое будет хранить список матриц для кадров анимации.
Также нам понадобится поле frameIndex, которое хранит индекс текущего кадра анимации.
Передавать кадры анимации мы будем в методе setAnimatedView. Он принимает массив кадров(матриц) и передает их списку frames.
В завершение, реализуем метод setStaticView, который задает изначальную матрицу для кораблей.

Требования:
1. В классе Ship должно существовать приватное поле frames типа List<int[][]>.
2. В классе Ship должно существовать приватное поле int frameIndex.
3. В классе Ship должен существовать публичный метод void setAnimatedView(int[][]... viewFrames).
4. В методе setAnimatedView(int[][]... viewFrames) необходимо вызвать метод setMatrix(int[][]) базового класса. В качестве параметра передай в метод viewFrames[0].
5. В методе setAnimatedView(int[][]... viewFrames) поле frames должно быть инициализировано значением Arrays.asList(viewFrames).
6. В методе setAnimatedView(int[][]... viewFrames) полю frameIndex необходимо установить значение 0.
7. В методе setStaticView(int[][] viewFrame) поле frames должно быть инициализировано новым объектом типа ArrayList<int[][]>.
8. В методе setStaticView(int[][] viewFrame) в список frames необходимо добавить объект viewFrame.
9. В методе setStaticView(int[][]) полю frameIndex необходимо установить значение 0.


==================================================================================================================================


Игра Space Invaders (19/34)
Реализуем "убийство" игрока, переопределив метод kill(). Помимо установки флага isAlive в состояние false, он будет добавлять анимацию уничтожения корабля.

Требования:
1. В классе PlayerShip должен быть переопределен метод kill() базового класса.
2. Метод kill() не должен ничего делать, если корабль игрока <неживой>.
3. В методе kill() класса PlayerShip полю isAlive необходимо установить значение false.
4. В методе kill() класса PlayerShip необходимо вызвать метод базового класса setAnimatedView(int[][]...) с параметрами: ShapeMatrix.KILL_PLAYER_ANIMATION_FIRST, ShapeMatrix.KILL_PLAYER_ANIMATION_SECOND, ShapeMatrix.KILL_PLAYER_ANIMATION_THIRD, ShapeMatrix.DEAD_PLAYER.


==================================================================================================================================


Игра Space Invaders (20/34)
Чтобы переключиться на следующий кадр анимации, в классе Ship создадим метод nextFrame.
Он устанавливает в поле matrix следующий кадр анимации, если это возможно.
Также расширим функционал метода draw, переопределив его таким образом, что бы он вызвал метод суперкласса для отрисовки и метод nextFrame для смены кадров анимации.

Требования:
1. В классе Ship должен существовать публичный метод void nextFrame().
2. В методе nextFrame() поле frameIndex необходимо увеличить на единицу.
3. Метод nextFrame() не должен ничего делать, если значение frameIndex больше либо равно количеству фреймов в списке frames.
4. В методе nextFrame() полю matrix необходимо присвоить фрейм из списка frames с индексом frameIndex.
5. В классе Ship должен быть переопределен метод родительского класса void draw(Game).
6. Метод draw(Game game) класса Ship должен вызвать метод суперкласса с параметром game.
7. Метод draw(Game game) класса Ship должен вызвать метод nextFrame().
8. В классе Ship должен быть импорт класса com.javarush.engine.cell.Game.


==================================================================================================================================


Игра Space Invaders (21/34)
При проигрыше и выигрыше игра останавливается. Давай реализуем метод stopGame, который будет останавливать игру и выводить соответствующее сообщение на экран.
Тексты сообщений о выигрыше или о проигрыше придумай сам.
Если пуля попала в игрока, перед остановкой игры нужно успеть показать анимацию взрыва. Для этого в методе stopGameWithDelay будем вызывать метод stopGame с задержкой.
В методе check, если игрок "неживой", нужно начинать отсчет задержки до остановки игры, вызвав метод stopGameWithDelay.

Требования:
1. В классе SpaceInvadersGame должно существовать приватное поле isGameStopped типа boolean.
2. Поле isGameStopped должно быть проинициализировано в методе createGame() значением false до вызова метода drawScene().
3. В классе SpaceInvadersGame должно существовать приватное поле animationsCount типа int.
4. Поле animationsCount должно быть проинициализировано в методе createGame() значением 0 до вызова метода drawScene().
5. В классе SpaceInvadersGame должен существовать приватный метод void stopGame(boolean isWin).
6. В методе stopGame(boolean isWin) значение поля isGameStopped должно быть установлено в true.
7. В методе stopGame(boolean isWin) необходимо вызвать метод stopTurnTimer().
8. В методе stopGame(boolean isWin), если параметр isWin истина, необходимо вызвать метод showMessageDialog(Color, String, Color, int). Цвет текста передай Color.GREEN.
9. В методе stopGame(boolean isWin), если параметр isWin ложь, необходимо вызвать метод showMessageDialog(Color, String, Color, int). Цвет текста передай Color.RED.
10. В классе SpaceInvadersGame должен существовать приватный метод void stopGameWithDelay().
11. В методе stopGameWithDelay() значение поля animationsCount необходимо увеличить на единицу.
12. В методе stopGameWithDelay() необходимо вызвать метод stopGame(boolean) с параметром playerShip.isAlive, если значение поля animationsCount больше либо равно 10.
13. В методе check() класса SpaceInvadersGame необходимо вызвать метод stopGameWithDelay(), если корабль игрока НЕ "живой".


==================================================================================================================================


Игра Space Invaders (22/34)
Добавим новое свойство кораблю игрока — направление движения. Задавать его будем через сеттер. Корабль может двигаться в двух направлениях — влево или вправо.
Но поскольку он может совсем не двигаться, для этого состояния будем использовать направление "вверх". Так как при старте корабль не двигается, установим направление "вверх" по умолчанию.
Для считывания команд игрока (нажатия клавиш) переопределим метод onKeyPress(Key) класса Game.
Этот метод будет устанавливать соответствующее направление кораблю при нажатии клавиши влево или вправо. Кроме этого реализуем перезапуск остановленной игры по нажатию клавиши пробел.

Требования:
1. В классе PlayerShip должно существовать приватное поле direction типа Direction, проинициализированное при объявлении значением Direction.UP.
2. В классе PlayerShip должен существовать публичный сеттер setDirection(Direction newDirection).
3. Сеттер setDirection(Direction newDirection) должен устанавливать полю direction значение newDirection, если newDirection не равен Direction.DOWN.
4. В классе SpaceInvadersGame должен быть переопределен метод onKeyPress(Key) родительского класса Game.
5. Метод onKeyPress(Key) должен вызывать метод createGame() и больше ничего не делать, если параметр метода — клавиша SPACE и игра была остановлена (isGameStopped == true).
6. Метод onKeyPress(Key) должен устанавливать кораблю игрока направление Direction.LEFT, если параметр метода — клавиша LEFT.
7. Метод onKeyPress(Key) должен устанавливать кораблю игрока направление Direction.RIGHT, если параметр метода — клавиша RIGHT.


==================================================================================================================================


Игра Space Invaders (23/34)
В этой части реализуем движение корабля игрока. Учти, что корабль не должен выходить за пределы игрового поля.
Чтобы корабль двигался вместе со всеми остальными объектами, необходимо вызывать метод move() в методе moveSpaceObjects() главного класса игры.

Требования:
1. В классе PlayerShip должен существовать публичный метод void move().
2. Метод move() не должен ничего делать, если значение поля isAlive — ложь.
3. В методе move(), если значение поля direction равно Direction.LEFT, необходимо уменьшить координату x на единицу.
4. В методе move(), если значение поля direction равно Direction.RIGHT, необходимо увеличить координату x на единицу.
5. В методе move(), если значение координаты x меньше нуля, необходимо установить этой координате значение 0.
6. В методе move(), если значение суммы полей x и width больше ширины игрового поля, необходимо установить координате x значение SpaceInvadersGame.WIDTH - width.
7. В методе moveSpaceObjects() класса SpaceInvadersGame у корабля игрока необходимо вызвать метод move().


==================================================================================================================================


Игра Space Invaders (24/34)
Когда ты отпускаешь клавиши влево или вправо, корабль игрока не прекращает движение, пока не дойдет до края игрового поля. Давай это исправим.
Переопределим метод onKeyReleased(Key) класса Game. Этот метод вызывается при отпускании клавиш.
Если корабль игрока движется, в результате работы метода onKeyReleased(Key) состояние поля direction у игрока изменится на Direction.UP и, как следствие, корабль прекратит движение.

Требования:
1. В классе PlayerShip должен существовать публичный геттер Direction getDirection(), возвращающий значение поля direction.
2. В классе SpaceInvadersGame должен быть переопределен метод onKeyReleased(Key) родительского класса Game.
3. Метод onKeyReleased(Key) должен устанавливать кораблю игрока направление Direction.UP, если параметр метода — клавиша LEFT и текущее направление корабля игрока равно Direction.LEFT.
4. Метод onKeyReleased(Key) должен устанавливать кораблю игрока направление Direction.UP, если параметр метода — клавиша RIGHT и текущее направление корабля игрока равно Direction.RIGHT.


==================================================================================================================================


Игра Space Invaders (25/34)
Сейчас подготовим возможность стрельбы для игрока. Для этого нам нужен метод fire, который будет создавать пули.
Хранить их будем в списке playerBullets. Добавь отрисовку пуль в метод drawScene, а их движение — в метод moveSpaceObjects.
Осталось только реализовать выстрел по нажатию клавиши. Этим мы займемся в следующей части.

Требования:
1. В классе PlayerShip должен быть переопределен метод fire() родительского класса Ship.
2. Метод fire() должен возвращать null, если корабль игрока "неживой".
3. Метод fire() должен возвращать новый объект типа Bullet. Конструктор класса Bullet необходимо вызвать с параметрами: x + 2, y - ShapeMatrix.BULLET.length, Direction.UP.
4. В классе SpaceInvadersGame должно существовать приватное поле playerBullets типа List<Bullet>.
5. Поле playerBullets должно быть проинициализировано в методе createGame() новым объектом типа ArrayList<Bullet> до вызова метода drawScene().
6. В методе drawScene() после вызова метода drawField() у каждого объекта из списка playerBullets должен быть вызван метод draw(Game). В качестве параметра передай в метод "this".
7. В методе moveSpaceObjects() у каждого объекта из списка playerBullets должен быть вызван метод метод move().


==================================================================================================================================


Игра Space Invaders (26/34)
В этой части добавим возможность стрелять по нажатию клавиши пробел.
Новосозданные пули игрока добавляются в список playerBullets, а те, которые вылетают за пределы игрового поля, удаляются из него.
Для удаления можно либо использовать итератор, либо создать копию списка playerBullets и проходить по ней циклом. Если в результате проверки объект нужно удалить из списка — вызывать playerBullets.remove(bullet).
Также ограничим максимальное количество пуль игрока на экране, чтобы немного усложнить игру. Для удобства вынесем это количество в переменную.
Переопределим метод setCellValueEx класса Game так, чтобы он работал только с валидными координатами.

Требования:
1. В классе SpaceInvadersGame должно существовать приватное статическое final int поле PLAYER_BULLETS_MAX, проинициализированное при объявлении значением 1.
2. Метод onKeyPress(Key) класса SpaceInvadersGame должен вызывать метод fire() у корабля игрока, если параметр метода — клавиша SPACE.
3. Если метод fire() вернул не null и количество объектов в списке playerBullets меньше PLAYER_BULLETS_MAX, необходимо добавить объект, который вернул метод fire(), в список playerBullets.
4. В методе removeDeadBullets() класса SpaceInvadersGame необходимо удалить все пули из списка playerBullets, если пуля "неживая" ИЛИ сумма координаты y и поля height пули меньше нуля.
5. В классе SpaceInvadersGame должен быть переопределен метод setCellValueEx(int, int, Color, String) родительского класса Game.
6. Метод setCellValueEx(int x, int y, Color, String) не должен ничего делать, если параметры метода x или y находятся вне поля.
7. Метод setCellValueEx(int, int, Color, String) должен вызывать метод родительского класса, используя ключевое слово super.


==================================================================================================================================


Игра Space Invaders (27/34)
Переопределим метод уничтожения для вражеского корабля. Он устанавливает значение false полю isAlive и задает матрицы для анимации уничтожения.
Также создадим в классе Ship метод isVisible().
Он будет возвращать false после того, как у "неживого" корабля отобразится вся анимация.

Требования:
1. В классе EnemyShip должен быть переопределен метод kill() родительского класса Ship.
2. Метод kill() не должен ничего делать, если корабль "неживой".
3. Метод kill() должен устанавливать полю isAlive значение false.
4. В методе kill() необходимо вызвать метод базового класса setAnimatedView(int[][]...) с параметрами: ShapeMatrix.KILL_ENEMY_ANIMATION_FIRST, ShapeMatrix.KILL_ENEMY_ANIMATION_SECOND, ShapeMatrix.KILL_ENEMY_ANIMATION_THIRD.
5. В классе Ship должен существовать публичный метод boolean isVisible().
6. Метод isVisible() должен возвращать false, если корабль "неживой" И frameIndex больше либо равно количеству объектов в списке frames. Иначе — true.


==================================================================================================================================


Игра Space Invaders (28/34)
На данном этапе добавим метод verifyHit(List<Bullet> bullets) для проверки попаданий пуль игрока во вражеские корабли.
После попадания нам нужно "убить" соответствующие пулю и вражеский корабль. Кроме этого, добавим метод deleteHiddenShips(), который будет удалять из списка "невидимые" корабли.
Для удаления можно либо использовать итератор, либо создать копию списка ships и проходить по ней циклом. Если в результате проверки объект нужно удалить из списка — вызывать ships.remove(ship).
Методы verifyHit(List<Bullet> bullets) и deleteHiddenShips() нужно вызвать в методе check() класса SpaceInvadersGame.

Требования:
1. В классе EnemyFleet должен существовать публичный метод void verifyHit(List<Bullet> bullets).
2. В методе verifyHit(List<Bullet> bullets) необходимо проверить пересечение каждого вражеского корабля из списка ships с каждой пулей из списка bullets, используя метод isCollision(GameObject).
3. Если пересечение корабля и пули есть (метод isCollision(GameObject) вернул true) и этот корабль "жив" и эта пуля "живая", необходимо вызвать вызвать у них метод kill().
4. В классе EnemyFleet должен существовать публичный метод void deleteHiddenShips().
5. Метод deleteHiddenShips() должен удалять из списка ships все не видимые на игровом поле корабли (ship.isVisible() == false).
6. В методе check() класса SpaceInvadersGame у объекта enemyFleet необходимо вызвать метод verifyHit(List<Bullet>) с параметром playerBullets до метода removeDeadBullets().
7. В методе check() класса SpaceInvadersGame у объекта enemyFleet необходимо вызвать метод deleteHiddenShips() после метода verifyHit(List<Bullet>).


==================================================================================================================================


Игра Space Invaders (29/34)
Пришло время создать главаря врагов. Чтобы он выглядел эффектнее, добавим анимацию при движении.
Если менять анимацию каждый такт, его движения будут казаться слишком быстрыми.
Чтобы они выглядели нормально, нужно менять кадр один раз в 10 тактов.
Именно поэтому нам нужно переопределить метод nextFrame и добавить переменную frameCount, которая будет вести отсчет тактов.

Требования:
1. В пакете gameobjects должен существовать публичный класс Boss.
2. Класс Boss должен быть наследником класса EnemyShip.
3. В классе Boss должен существовать публичный конструктор с двумя параметрами типа double, который вызывает конструктор базового класса с этими же параметрами.
4. В конструкторе класса Boss необходимо вызвать метод setAnimatedView(int[][]...) с параметрами: ShapeMatrix.BOSS_ANIMATION_FIRST, ShapeMatrix.BOSS_ANIMATION_SECOND.
5. В классе Boss должно существовать приватное поле frameCount типа int, инициализированное при объявлении значением 0.
6. В классе Boss должен быть переопределен метод nextFrame() родительского класса Ship.
7. Метод nextFrame() должен увеличивать значение поля frameCount на единицу.
8. Метод nextFrame() должен вызвать метод суперкласса nextFrame(), если остаток от деления frameCount на 10 равен нулю или босс неживой.
9. В методе createShips() класса EnemyFleet необходимо создать и добавить в список ships новый объект типа Boss. Конструктор класса необходимо вызвать с параметрами STEP * COLUMNS_COUNT / 2 - ShapeMatrix.BOSS_ANIMATION_FIRST.length / 2 - 1 и 5.


==================================================================================================================================


Игра Space Invaders (30/34)
Сейчас научим босса стрелять. В зависимости от кадра анимации, босс будет стрелять из разных пушек.
Также переопределим метод kill(), в котором установим значение поля isAlive и зададим кадры анимации взрыва.

Требования:
1. В классе Boss должен быть переопределен метод fire() родительского класса EnemyShip.
2. Метод fire() должен вернуть null, если босс "неживой".
3. Метод fire() должен вернуть новый объект типа Bullet.
4. В методе fire() нужно вызвать конструктор класса Bullet с параметрами: x + 6, y + height, Direction.DOWN, если matrix == ShapeMatrix.BOSS_ANIMATION_FIRST.
5. В методе fire() нужно вызвать конструктор класса Bullet с параметрами: x, y + height, Direction.DOWN, если matrix != ShapeMatrix.BOSS_ANIMATION_FIRST.
6. В классе Boss должен быть переопределен метод kill() родительского класса EnemyShip.
7. Метод kill() не должен ничего делать, если босс "неживой".
8. В методе kill() полю isAlive необходимо установить значение false.
9. В методе kill() необходимо вызвать метод базового класса setAnimatedView(int[][]...) с параметрами: ShapeMatrix.KILL_BOSS_ANIMATION_FIRST, ShapeMatrix.KILL_BOSS_ANIMATION_SECOND, ShapeMatrix.KILL_BOSS_ANIMATION_THIRD.


==================================================================================================================================


Игра Space Invaders (31/34)
Давай сделаем так, чтобы анимация босса была постоянной. Для этого нам нужно добавить в метод setAnimatedView параметр isLoopAnimation, отвечающий за бесконечность анимации.
Этот параметр устанавливает соответствующее значение полю loopAnimation.
Если значение поля loopAnimation равно true, метод nextFrame повторяет кадры, сбрасывая frameIndex.
Вледствие этого нужно отрефакторить параметры в местах вызова метода setAnimatedView.

Требования:
1. В классе Ship должно существовать приватное поле loopAnimation типа boolean, проинициализированное при объявлении значением false.
2. В классе Ship должен существовать публичный метод void setAnimatedView(boolean isLoopAnimation, int[][]... viewFrames).
3. В классе Ship не должен существовать публичный метод void setAnimatedView(int[][]... viewFrames).
4. Метод setAnimatedView(boolean isLoopAnimation, int[][]... viewFrames) должен устанавливать полю loopAnimation значение isLoopAnimation.
5. Метод nextFrame() класса Ship не должен ничего делать, если значение frameIndex больше либо равно количеству фреймов в списке frames и loopAnimation равен false.
6. Метод nextFrame() класса Ship должен устанавливать полю frameIndex значение 0, если значение frameIndex больше либо равно количеству фреймов в списке frames и loopAnimation равен true.
7. В методе kill() класса PlayerShip необходимо вызвать метод базового класса setAnimatedView(boolean, int[][]...) с параметрами: false, ShapeMatrix.KILL_PLAYER_ANIMATION_FIRST, ShapeMatrix.KILL_PLAYER_ANIMATION_SECOND, ShapeMatrix.KILL_PLAYER_ANIMATION_THIRD, ShapeMatrix.DEAD_PLAYER.
8. В методе kill() класса EnemyShip необходимо вызвать метод базового класса setAnimatedView(boolean, int[][]...) с параметрами: false, ShapeMatrix.KILL_ENEMY_ANIMATION_FIRST, ShapeMatrix.KILL_ENEMY_ANIMATION_SECOND, ShapeMatrix.KILL_ENEMY_ANIMATION_THIRD.
9. В методе kill() класса Boss необходимо вызвать метод базового класса setAnimatedView(boolean, int[][]...) с параметрами: false, ShapeMatrix.KILL_BOSS_ANIMATION_FIRST, ShapeMatrix.KILL_BOSS_ANIMATION_SECOND, ShapeMatrix.KILL_BOSS_ANIMATION_THIRD.
10. В конструкторе класса Boss необходимо вызвать метод базового класса setAnimatedView(boolean, int[][]...) с параметрами: true, ShapeMatrix.BOSS_ANIMATION_FIRST, ShapeMatrix.BOSS_ANIMATION_SECOND.


==================================================================================================================================


Игра Space Invaders (32/34)
Игра проиграна не только если корабль игрока уничтожен, но и когда вражеский флот вплотную приблизился к кораблю игрока.
Чтобы определить координаты нижней границы вражеского флота, добавим метод getBottomBorder().
После разгрома всех врагов игрок побеждает. Для удобства добавим метод getShipsCount(), который будет возвращать количество оставшихся кораблей вражеского флота.
Если количество равно 0, нужно вызвать метод stopGameWithDelay() и win() у объекта playerShip, который поменяет матрицу корабля игрока на ShapeMatrix.WIN_PLAYER.
Проверку количества оставшихся вражеских кораблей и достижения ими корабля игрока выполним в методе check().

Требования:
1. В классе EnemyFleet должен существовать публичный метод double getBottomBorder().
2. Метод getBottomBorder() должен возвращать максимальное из значений (y + height) среди всех вражеских кораблей из списка ships.
3. В классе EnemyFleet должен существовать публичный метод int getShipsCount().
4. Метод getShipsCount() должен возвращать количество вражеских кораблей в списке ships.
5. В классе PlayerShip должен существовать публичный метод void win().
6. В методе win() класса PlayerShip необходимо вызвать метод setStaticView(int[][]). В качестве параметра передай ShapeMatrix.WIN_PLAYER.
7. В методе check() класса SpaceInvadersGame необходимо вызвать метод getBottomBorder() у объекта enemyFleet.
8. Если результат вызова метода getBottomBorder() больше либо равен playerShip.y, в методе check() необходимо вызвать метод kill() у объекта playerShip.
9. В методе check() класса SpaceInvadersGame необходимо вызвать метод getShipsCount() у объекта enemyFleet.
10. Если результат вызова метода getShipsCount() равен 0, в методе check() необходимо вызвать метод win() у объекта playerShip и метод stopGameWithDelay() класса SpaceInvadersGame.


==================================================================================================================================


Игра Space Invaders (33/34)
На данном этапе мы добавим в игру счет очков. За обычный корабль начислять будем 15 очков, а за босса — 100.
Для подсчета очков удобнее всего использовать метод verifyHit, немного доработав его.
Чтобы вести общий счет, добавим переменную score в класс SpaceInvadersGame. Будем выводить ее на экран с помощью метода setScore класса Game.

Требования:
1. В классе EnemyShip должно существовать публичное поле score типа int, проинициализированное при объявлении значением 15.
2. В конструкторе класса Boss необходимо установить полю score значение 100.
3. В классе EnemyFleet должен существовать публичный метод int verifyHit(List<Bullet> bullets).
4. В классе EnemyFleet не должен существовать публичный метод void verifyHit(List<Bullet> bullets).
5. Метод verifyHit(List<Bullet> bullets) должен возвращать 0, если список bullets пустой.
6. Метод verifyHit(List<Bullet> bullets) должен возвращать сумму значений полей score всех объектов из списка ships, для которых был вызван метод kill().
7. В классе SpaceInvadersGame должно существовать приватное поле score типа int.
8. Поле score должно быть проинициализировано в методе createGame() значением 0.
9. Метод onTurn(int) должен вызвать метод setScore(int) с параметром score.
10. В методе onTurn(int) метод setScore(int) должен быть вызван до метода drawScene().
11. В методе check() значение поля score должно быть увеличено на результат, который вернул вызов метода verifyHit(List<Bullet>) у объекта enemyFleet.


==================================================================================================================================


Игра Space Invaders (34/34)
Наши поздравления: игра написана! Предлагаем запустить ее и посмотреть, что получилось.
Если есть время и вдохновение, можешь улучшить игру, добавив некоторые "фичи" от себя.
Например:
- добавить другие типы кораблей;
- изменить количество пушек у кораблей;
- добавить новые виды снарядов;
- поменять систему начисления очков: например, чем быстрее уничтожен корабль, тем больше очков за него дается;
- добавить укрытия для игрока;
- при попадании в определенный корабль получать бонусы: например, временное бессмертие, супероружие и т.д.;
- в случае победы — переход на следующие уровни;
- и всё, что тебе позволит фантазия :)
Готовую игру ты можешь опубликовать на JavaRush. Но перед этим нужно отправить свое решение на проверку, чтобы кнопка публикации стала активной. Игра будет доступна в разделе «Игры» всем пользователям.
А еще ты можешь поделиться ею с друзьями в соцсетях. Будет здорово, если они сыграют в твою версию "Space Invaders", не так ли?
После публикации в комментариях напиши краткую инструкцию (какие действия доступны, какие клавиши или кнопки нужно использовать для игры), а также особенности твоей реализации.

Требования:
1. Запусти игру и поиграй.
