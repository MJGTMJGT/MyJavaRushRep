Игра змейка (1/20)
Давай напишем игру "Змейка".

Правила игры:

Игрок управляет движением змейки, которая ползает по квадратному полю: вверх, вниз, вправо и влево.
Остановить движение змейки нельзя.
Цель игры — съесть как можно большее количество яблок, которые появляются поочередно, в случайном месте игрового поля, как только змейка "проглотит" предыдущее.
С каждым новым яблоком змейка растет на один сегмент (занимает на одну ячейку больше). В нашей игре на старте змейка занимает три ячейки (имеет три сегмента) и может дорасти до 28.
По мере того, как растет змейка, скорость игры увеличивается.
Змейка не может проходить "сквозь себя" или выходить за пределы игрового поля.
Игра оканчивается победой, если длина змейки увеличилась до 28 сегментов.
Игра оканчивается проигрышем, если касается сама себя или края поля.
Теперь приступаем к реализации игры:

Нам понадобится класс, который будет содержать логику игры. Назовем его SnakeGame.

Не забудь унаследовать его от класса Game.

Этот и другие классы "игрового движка" находятся в пакете com.javarush.engine.cell, и чтобы ими пользоваться, класс SnakeGame должен содержать такой импорт:
import com.javarush.engine.cell.*;

Если ты все сделал правильно, уже можно запустить SnakeGame и увидеть пустое игровое поле.

Теперь создай переменные для хранения ширины и высоты игрового поля.
Переопредели метод родительского класса public void initialize(): он будет содержать команды, которые выполнятся один раз при запуске игры. Например, установка размеров игрового поля.
Также, советуем прочесть статью про раздел "Игры". В ней ты найдешь информацию, которая будет полезна при написании игр.


Требования:
1. Должен существовать публичный класс SnakeGame.
2. Класс SnakeGame должен быть наследником класса Game.
3. В классе SnakeGame должно существовать поле public static final int WIDTH, инициализированное при объявлении значением 15.
4. В классе SnakeGame должно существовать поле public static final int HEIGHT, инициализированное при объявлении значением 15.
5. В классе SnakeGame должен быть переопределен метод initialize() родительского класса Game.
6. В методе initialize() должен быть вызван метод setScreenSize(int, int) класса Game c параметрами WIDTH и HEIGHT.
7. В классе SnakeGame должен быть импорт всего содержимого пакета com.javarush.engine.cell.

==================================================================================================================================


Игра змейка (2/20)
Давай раскрасим игровое поле. Это можно сделать в методе initialize как и все остальные действия игры. Но "лепить" все в один метод - плохая практика. Поэтому изначально создадим несколько необходимых методов, каждый из которых будет отвечать за определенный кусок работы: метод drawScene - за отрисовку экрана, метод createGame - за действия, которые нужно выполнить для создания игры. Исходя из этого нам нужно в методе initialize() вызвать метод createGame(), в котором в свою очередь будет вызываться метод drawScene().

Чтобы окрасить ячейки игрового поля в определенный цвет нужно пройти по всем ячейкам (используй циклы) и для каждой из них вызвать метод setCellColor.

Подсказка:

for (int x = 0; x < WIDTH; x++) {
    for (int y = 0; y < HEIGHT; y++) {
        setCellColor(x, y, Color);
    }
}

Требования:
1. В классе SnakeGame должен существовать private void метод createGame().
2. В классе SnakeGame должен существовать private void метод drawScene().
3. В методе createGame() должен быть вызван метод drawScene().
4. В методе initialize() должен быть вызван метод createGame().
5. В методе initialize() метод createGame() вызывается после метода setScreenSize(int, int).
6. В методе drawScene() для каждой ячейки игрового поля вызови метод setCellColor(int, int, Color) с параметрами: координаты x и y и любой цвет. Например, Color.DARKSEAGREEN).


==================================================================================================================================


Игра змейка (3/20)
Для хранения объектов игрового поля нам понадобится дополнительный класс.

Объект этого класса будет хранить координаты соответствующей ячейки.

Назовем его GameObject.

Требования:
1. Должен существовать публичный класс GameObject.
2. В классе GameObject должно существовать публичное поле x типа int.
3. В классе GameObject должно существовать публичное поле y типа int.
4. В классе GameObject должен существовать один конструктор с двумя параметрами типа int, который устанавливает соответствующие значения полям x и y.


==================================================================================================================================


Игра змейка (4/20)
Одним из игровых объектов будет яблоко. Создай для него класс Apple и унаследуй его от класса GameObject.

Чтобы отобразить яблоко на игровом поле, можно покрасить ячейку, содержащую яблоко, в какой-нибудь цвет. Или можно вывести в этой ячейке какой-нибудь символ, похожий на яблоко. Пусть класс Apple хранит этот символ в переменной APPLE_SIGN.

В классе Apple добавь метод draw(Game): он будет отрисовывать яблоко на игровом поле. Для этого в методе draw(Game game) нужно вызвать: game.setCellValueEx(...)..

Так как в классе Apple используются классы Game и Color, а эти (и другие) классы "движка" находятся в пакете com.javarush.engine.cell, то чтобы ими пользоваться, класс Apple должен содержать такой импорт:
import com.javarush.engine.cell.*;

Чтобы посмотреть, как будет выглядеть яблоко, в методе createGame() создай новое с координатами (7, 7) и вызови у него метод draw(Game).


Требования:
1. Должен существовать публичный класс Apple.
2. Класс Apple должен быть наследником класса GameObject.
3. В классе Apple должен существовать один конструктор с двумя параметрами типа int (x и y), который вызывает конструктор базового класса с параметрами x и y, используя ключевое слово super.
4. В классе Apple должно существовать приватное статическое final поле String APPLE_SIGN, инициализированное при объявлении. Например, использовать можно UTF-16 символ яблока "\uD83C\uDF4E".
5. В классе Apple должен существовать публичный void метод draw(Game).
6. В методе draw(Game) должен быть вызван метод setCellValueEx(int, int, Color, String, Color, int) у объекта типа Game с параметрами: x, y, Color.NONE, APPLE_SIGN, <цвет яблока>, 75. (<цвет яблока> используй какой тебе нравится, например, Color.GREEN).
7. В методе createGame() класса SnakeGame должно быть создано новое яблоко (экземпляр класса Apple) с координатами: 7, 7.
8. У созданного яблока должен быть вызван метод draw(Game). В качестве параметра метода передай this.
9. В классе Apple должен быть импорт всего содержимого пакета com.javarush.engine.cell.


==================================================================================================================================


Игра змейка (5/20)
Теперь займемся змейкой, а тестовое создание и отрисовку яблока в createGame() удалим.

Создай класс Snake. Змейка будет состоять из нескольких ячеек, т.е. из нескольких GameObject-ов. Кроме того, их количество может изменяться: оно будет увеличиваться при поедании яблок. Список всех сегментов змейки будем хранить в поле List<GameObject> snakeParts.

В классе Snake добавь конструктор, который будет создавать сразу три сегмента змейки.


Требования:
1. В методе createGame() класса SnakeGame не должно создаваться новое яблоко.
2. Должен существовать публичный класс Snake.
3. В классе Snake должен существовать один публичный конструктор с двумя параметрами типа int (x и y).
4. В классе Snake должно быть создано приватное поле List<GameObject> snakeParts, инициализированное при объявлении новым списком типа ArrayList<>.
5. В конструкторе должны быть созданы три объекта типа GameObject с параметрами: первый – (x, y); второй – (x + 1, y); третий – (x + 2, y).
6. Созданные в конструкторе объекты типа GameObject должны быть добавлены в список snakeParts в порядке: первый, второй, третий.


==================================================================================================================================


Игра змейка (6/20)
Когда у нас уже есть змейка, нужно её отрисовать. Для этого, по аналогии с классом Apple, в классе Snake создай константы HEAD_SIGN и BODY_SIGN, которые будут хранить символы для отрисовки головы и тела змейки. Также создай метод draw(Game), который должен отрисовывать змейку на игровом поле.

Управлять отрисовкой змейки будем из класса SnakeGame. Поэтому создай переменную Snake snake в классе SnakeGame: в ней будет храниться текущее состояние змейки.

В методе createGame() создай новую змейку в центре игрового поля и присвой её переменной snake. В методе drawScene() вызови у змейки метод draw(Game), чтобы отобразить её на игровом поле.


Требования:
1. В классе Snake должно существовать приватное статическое final поле String HEAD_SIGN, инициализированное при объявлении. Например, использовать можно UTF-16 символ "\uD83D\uDC7E".
2. В классе Snake должно существовать приватное статическое final поле String BODY_SIGN, инициализированное при объявлении. Например, использовать можно UTF-8 символ "\u26AB".
3. В классе Snake должен существовать публичный void метод draw(Game game).
4. В методе draw(Game) должен вызываться метод setCellValue(int, int, String) класса Game для каждого объекта GameObject из списка snakeParts.
5. Метод setCellValue(int, int, String) для головы змеи (элемент с индексом 0 из списка snakeParts) должен вызываться с параметрами x и y головы, и HEAD_SIGN.
6. Метод setCellValue(int, int, String) для каждого сегмента тела змеи (элементы с индексом не 0 из списка snakeParts) должен вызываться с параметрами x и y сегмента, и BODY_SIGN.
7. В классе SnakeGame должно существовать приватное поле Snake snake.
8. В методе createGame() класса SnakeGame должна быть создана новая змея (экземпляр класса Snake) с координатами: WIDTH / 2, HEIGHT / 2 перед вызовом метода drawScene().
9. В методе createGame() полю snake необходимо присвоить ссылку на созданный объект типа Snake.
10. В методе drawScene() последним должен быть вызван метод draw(Game) у объекта snake. В качестве параметра метода передай this.
11. В классе Snake должен быть импорт всего содержимого пакета com.javarush.engine.cell.


==================================================================================================================================


Игра змейка (7/20)
Объект на игровом поле может иметь одно из двух состояний: он может быть или "жив" (isAlive=true), или нет (isAlive=false).
Например, если змейка ударяется о край игрового поля, она умирает. То же происходит с яблоком, когда его съедает змейка. Чтобы хранить состояние объектов, создай в классах Apple и Snake переменную boolean isAlive. Измени отрисовку змейки таким образом, чтобы "неживая" змейка была красного цвета.

Змейка может двигаться в одном из четырех направлений. Чтобы указать направления, создай enum Direction со значениями UP, RIGHT, DOWN, LEFT, а в классе Snake — поле direction, которое будет хранить текущее направление движения. Пусть изначально змейка двигается влево. Изменять направление движения змейки будем методом setDirection(Direction). Создай его.


Требования:
1. В классе Apple должно существовать публичное поле boolean isAlive, инициализированное значением true.
2. В классе Snake должно существовать публичное поле boolean isAlive, инициализированное значением true.
3. В методе draw(Game) класса Snake замени все вызовы метода setCellValue(int, int, String) на вызовы метода setCellValueEx(int, int, Color, String, Color, int) с параметрами: x, y, Color.NONE, HEAD_SIGN (или BODY_SIGN), <цвет змейки>, 75. Если змейка "неживая", ее цвет должен быть Color.RED. Иначе — любой другой, например, Color.BLACK.
4. Должен существовать публичный enum Direction со значениями: UP, RIGHT, DOWN, LEFT.
5. В классе Snake должно существовать приватное поле Direction direction, инициализированное при объявлении значением Direction.LEFT.
6. В классе Snake должен существовать публичный сеттер поля direction — setDirection(Direction), который устанавливает полю класса значение, полученное в качестве параметра.


==================================================================================================================================



